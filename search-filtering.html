<link rel="import" href="~/Scripts/Polymer/polymer/polymer.html" />

<polymer-element name="CheckBox-Master" attributes="items groupTitle">    
    <template> 
               
        <style>            
            paper-checkbox {                
                margin-top: 20px; margin-right: 20px;
            }         
           
            div#Container {
                margin: 10px;
            }
        </style>

        <div id="Container">
            <content>
                <h1>{{groupTitle}}</h1>
            </content>

            <form class="controls" id="Filters">
                <fieldset>
                    <template repeat="{{item in items}}">
                        <div horizontal layout>                           
                            <paper-checkbox data-search="{{item}}"></paper-checkbox>                                                        
                            <h3>{{item}}</h3>                                                            
                            <br />
                        </div>
                    </template>
                </fieldset>               
            </form>            
        </div>

    </template>
    
    <script>
        
        Polymer({

            $filters: null,
            $reset: null,
            groups: [],
            outputArray: [],
            outputString: '',

            created: function () {
                this.items = [];
            },

            ready: function () {
                this.init();
            },

            displaySearch: function() {
                this.fire('searchChanged', {search: this.outputString});
            },

            init: function () {
                var self = this; // As a best practice, in each method we will asign "this" to the variable "self" so that it remains scope-agnostic. We will use it to refer to the parent "checkboxFilter" object so that we can share methods and properties between all parts of the object.
                
                this.$filters = this.$.Filters;
                self.$reset = this.$.Reset
                self.$container = this.$.Container;

                var lists = [].slice.call(this.$filters.querySelectorAll('fieldset'));                
          
                for (i = 0; i < lists.length; ++i) {                    
                    this.groups.push({
                        $inputs: lists[i].querySelectorAll('paper-checkbox'),
                        active: [],
                        tracker: false
                    });
                }
                console.log('groups');
                console.log(this.groups);
                self.bindHandlers();
            },

            // The "bindHandlers" method will listen for whenever a form value changes.

            bindHandlers: function () {
                var self = this;             

                self.$filters.addEventListener("change", self.parseFilters.bind(this), false);

                //self.$reset.on('click', function (e) {
                //    e.preventDefault();
                //    self.$filters[0].reset();
                //    self.parseFilters();
                //});
            },

            // The parseFilters method checks which filters are active in each group:

            parseFilters: function () {
                var self = this;

                // loop through each filter group and add active filters to arrays
                console.log('Here comes the parse group');
                console.log(this.groups);

                //for (var i = 0, group; group = self.groups[i]; i++) {
                //    group.active = []; // reset arrays
                //    group.$inputs.each(function () {
                //        console.log(this);
                //        $(this).is(':checked') && group.active.push(this.value);
                //    });
                //    group.active.length && (group.tracker = 0);
                //}

                for (var i = 0, group; group = self.groups[i]; i++) {
                    group.active = []; // reset arrays
                    for (var i = 0; i < group.$inputs.length; i++)
                    {                    
                        console.log(group.$inputs[i]);
                        if (group.$inputs[i].checked === true) {
                            group.active.push(group.$inputs[i].dataset.search);
                        }
                    };

                    group.active.length && (group.tracker = 0);
                }

                self.concatenate();
            },

            // The "concatenate" method will crawl through each group, concatenating filters as desired:

            concatenate: function () {
                var self = this,
                      cache = '',
                      crawled = false,
                      checkTrackers = function () {
                          var done = 0;

                          for (var i = 0, group; group = self.groups[i]; i++) {
                              (group.tracker === false) && done++;
                          }

                          return (done < self.groups.length);
                      },
                  crawl = function () {
                      for (var i = 0, group; group = self.groups[i]; i++) {
                          group.active[group.tracker] && (cache += group.active[group.tracker]);

                          if (i === self.groups.length - 1) {
                              self.outputArray.push(cache);
                              cache = '';
                              updateTrackers();
                          }
                      }
                  },
                  updateTrackers = function () {
                      for (var i = self.groups.length - 1; i > -1; i--) {
                          var group = self.groups[i];

                          if (group.active[group.tracker + 1]) {
                              group.tracker++;
                              break;
                          } else if (i > 0) {
                              group.tracker && (group.tracker = 0);
                          } else {
                              crawled = true;
                          }
                      }
                  };

                self.outputArray = []; // reset output array

                do {
                    crawl();
                }
                while (!crawled && checkTrackers());

                self.outputString = self.outputArray.join();

                // If the output string is empty, show all rather than none:

                !self.outputString.length && (self.outputString = 'all');

                console.log('Final String:');
                console.log(self.outputString);

                this.displaySearch();

                // ^ we can check the console here to take a look at the filter string that is produced

                // Send the output string to MixItUp via the 'filter' method:

                //if (self.$container.mixItUp('isLoaded')) {
                //    self.$container.mixItUp('filter', self.outputString);
                //}
            }
        });


    </script>
</polymer-element>

